import numpy as np
import math

k = 365

class CompanyAgent:
    """The Company Agent class represents a company agent in the Emission Trading System (ETS) market.
    Properties:
        expected_emission (float): The expected emission over the course of the year.
        allowance (float): The allowance for the year.
        emission_rate (float): The emission rate (emission per day).
        emission_rate_noise (float): The noise in the emission rate (emission per day). Sampled from a normal distribution.
        total_emission (float): The total emission produced by the company so far.
        day (int): The day of the year.
        expected_deficit (float): The expected deficit of the company (expected emissions - allowance).
        expected_market_price (float): The expected market price from the company's perspective.
        sale_counter (int): The number of successful sales.
        buy_counter (int): The number of successful buys.
        count (int): The number of allowances to buy or sell.
        state (str): The state of the company (buy, sell, or idle).
        trade_price (float): The price at which the company is willing to trade.
        abatement_costs (list): The abatement costs for the company (cost to permanently reduce emission rate by 1 ton per day).
        abatement_cost_per_ton (float): The abatement cost per ton. If this cost is less than the expected CO2 price, the company will abate.
        min_sell_price (float): The minimum price at which the company can sell the allowances.
        max_buy_price (float): The maximum price at which the company can buy the allowances.
        expected_emission_noise (float): Initial uncertainty in the expected emission.
    """
    def __init__(self, expected_emission, initial_allowance, min_sell_price, max_buy_price, expected_emission_noise=0.1, emission_rate_noise=0.01, activate_abatement=True, advanced_trading=False):
        """Initialize the Company Agent.
        Args:
            expected_emission (float): The expected emission over the course of the year.
            initial_allowance (float): The initial allowance for the year.
            min_sell_price (float): The minimum price at which the company can sell the allowances.
            max_buy_price (float): The maximum price at which the company can buy the allowances.
            expected_emission_noise (float): Initial uncertainty in the expected emission.
            emission_rate_noise (float): The noise in the emission rate (emission per day).
            activate_abatement (bool): Whether to activate abatement or not.
            advanced_trading (bool): Whether to use advanced trading strategies or not.
        """

        self.expected_emission = expected_emission + np.random.normal(scale=expected_emission_noise) 
        self.allowance = initial_allowance

        self.emission_rate = (self.expected_emission) / 365.0   # Add some noise
        self.emission_rate_noise = emission_rate_noise

        self.total_emission = 0
        self.day = 0
        self.expected_deficit = self.expected_emission - self.allowance

        self.expected_market_price = (min_sell_price+max_buy_price)/2
        
        self.sale_counter = 0
        self.buy_counter = 0
        self.count = 0
        self.state = "idle"
        self.trade_price = self.expected_market_price

        self.abatement_costs = self.init_abatement_costs()  # cost to permanently reduce rate by 1 ton 
        if not activate_abatement:
            self.abatement_costs = [np.inf]
        self.abatement_cost_per_ton = float(np.inf)

        self.min_sell_price = min_sell_price
        self.max_buy_price = max_buy_price

        if advanced_trading:
            self.update_market_position = self.update_market_position_advanced_training
        else:
            self.update_market_position = self.update_market_position_simple
    
        self.last_k_emissions = [] 

    def init_abatement_costs(self):
        '''
        Initialize the abatement costs for the company.
        The initial abatement cost is generated using a gamma distribution. 
        The following abatement costs are generated by adding a random normal noise to the previous abatement cost (which is clamped to 0).
        Taking only positive values makes sure that the abatement costs increase over the number of reductions.
        '''
        abatement_costs = []
        start_value=np.random.gamma(shape=2.5, scale=10000)
        variance_factor=np.random.uniform(0.1 , 100)
        for variance in range(365):
            start_value += max(np.random.normal(scale=variance*variance_factor) + np.random.uniform(0,1000), 0)
            abatement_costs.append(start_value)
        return abatement_costs

    def update_emission_rate(self):
        """
        Update the emission rate. Models the emission rate as a Wiener process.
        """
        self.emission_rate = max(0, self.emission_rate + np.random.normal(scale=self.emission_rate_noise))

    def track_emission(self):
        """
        Track the emissions produced by the company.
        """
        self.total_emission += self.emission_rate
        self.last_k_emissions.append(self.emission_rate)
        if len(self.last_k_emissions) > k:
            self.last_k_emissions.pop(0)

    def update_abatements(self):
        """
        Update the abatement costs per ton for the company. It is calculated over the remaining days of the year.
        """
        # The first element is always the current abatement cost -> if its taken, its popped
        self.abatement_cost_per_ton = self.abatement_costs[0] / (366 - self.day) 

    def update_expected_emission(self):
        """
        Update the expected emission for the company. Only the last k emissions are considered.
        """
        expected_emissions_last_k = sum(self.last_k_emissions)/len(self.last_k_emissions)*(365)
        self.expected_emission = math.ceil((expected_emissions_last_k - 1e-9))
        self.expected_deficit = int(self.expected_emission - self.allowance)

    def update_market_position_simple(self):
        """
        post trade is necessary
        """

        if self.expected_deficit > 0:
            #buy or abate
            if self.expected_market_price > self.abatement_cost_per_ton:
                self.state = "idle"
                self.count = 0
                self.abatement_costs.pop(0)
                self.emission_rate -= 1
            else:
                self.count = math.ceil(self.expected_deficit)
                self.state = "buy"
                self.trade_price = min(self.expected_market_price, self.max_buy_price)
        elif self.expected_deficit <= -1:
            #sell
            self.count = (-1)*math.ceil(self.expected_deficit)
            self.state = "sell"
            self.trade_price = max(self.expected_market_price, self.min_sell_price)
        else:
            self.state = "idle"
            self.count = 0

    def update_market_position_advanced_training(self):
        """
        post trade is necessary
        """

        if self.expected_deficit > 0:
            #buy or abate
            if self.expected_market_price > self.abatement_cost_per_ton:
                self.state = "idle"
                self.count = 0
                self.abatement_costs.pop(0)
                self.emission_rate -= 1
            else:
                self.count = math.ceil(self.expected_deficit)
                self.count = min(self.count, np.random.uniform(self.day/365, 1.3) * self.count)
                self.state = "buy"
                self.trade_price = min(self.expected_market_price, self.max_buy_price)
        elif self.expected_deficit <= -30 or (self.day > 360 and self.expected_deficit < - 10):
            #sell
            self.count = (-1)*math.ceil(self.expected_deficit) - 10
            self.count = min(self.count, np.random.uniform(self.day/400, 0.99) * self.count)
            self.state = "sell"
            self.trade_price = max(self.expected_market_price, self.min_sell_price)
        else:
            self.state = "idle"
            self.count = 0
    
    def sell_allowance(self, price, trade_amount):
        self.allowance -= trade_amount
        self.count -= trade_amount
        self.sale_counter += trade_amount


    def buy_allowance(self, price, trade_amount):
        self.allowance += trade_amount
        self.count -= trade_amount
        self.buy_counter += trade_amount
        

    def failed_sell(self):
        self.sale_counter -= self.count
    
    def failed_buy(self):
        self.buy_counter -= self.count

    def update_expected_market_price(self, market_price):
        
        if self.state == "sell":
            if self.sale_counter > 0: #successful sales
                self.expected_market_price += 1
            elif self.sale_counter < 0: #unsuccessful sales
                if self.expected_market_price > self.min_sell_price: #only reduce when min price was not used
                    self.expected_market_price -= 1

        elif self.state == "buy":
            if self.buy_counter > 0: #successful buys
                self.expected_market_price -= 1
            elif self.buy_counter < 0: #unsuccessful buys
                if self.expected_market_price < self.max_buy_price: #only increase when max price was not used
                    self.expected_market_price += 1
        elif self.state == 'idle' and self.day > 1:
            if self.expected_market_price > market_price:
                self.expected_market_price -= 1
            elif self.expected_market_price < market_price:
                self.expected_market_price += 1


        self.buy_counter = 0
        self.sale_counter = 0
        return

    def update_agent(self, market_price):
        """
        Update the agent.
        """
        self.day += 1
        self.update_expected_market_price(market_price)
        self.update_emission_rate()
        self.update_abatements()
        self.track_emission()
        self.update_expected_emission()
        self.update_market_position()

    def __lt__(self, other):
        """
        Compare two Company Agents.
        """
        # return randomly true or false
        return np.random.choice([True, False])

    def __str__(self):
        """
        String representation of the Company Agent.
        """
        return f"Company Agent - Initial Expected Emission: {self.initial_exepected_emission}, Initial Allowance: {self.initial_allowance}, " \
               f"Sell Price: {self.sell_price}, Buy Price: {self.buy_price}, Emission Rate: {self.emission_rate} " \
               f"Total Emission: {self.total_emission}, Expected Emission: {self.expected_emission}, Allowance: {self.allowance}"
    
    def get_sell_price(self):
        return self.sell_price
    
    def get_buy_price(self):
        return self.buy_price